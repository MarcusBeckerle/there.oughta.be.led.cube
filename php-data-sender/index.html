<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>LED Cube Control</title>

<link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.15/tailwind.min.css"
      crossorigin="anonymous" referrerpolicy="no-referrer" />

<style>
  body {
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    background: #e5e7eb;
  }

  .card {
    width: 980px;
    margin: 36px auto;
    background: #fff;
    border-radius: 14px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.15);
    overflow: hidden;
  }

  header {
    display: flex;
    align-items: center;
    padding: 18px 20px;
    background: #111827;
    color: #fff;
  }

  header img {
    width: 140px;
    height: 140px;
    object-fit: cover;
    border-radius: 10px;
    margin-right: 18px;
    border: 1px solid rgba(255,255,255,0.15);
  }

  header h1 {
    margin: 0;
    font-size: 22px;
    font-weight: 700;
    letter-spacing: 0.2px;
  }

  .content {
    display: flex;
    min-height: 620px;
  }

  /* LEFT: CONTROLS */
  .controls {
    width: 460px;
    padding: 18px 18px 22px 18px;
    border-right: 1px solid #e5e7eb;
  }

  .tabs {
    display: flex;
    margin-bottom: 14px;
  }

  .tab {
    padding: 10px 14px;
    cursor: pointer;
    border-bottom: 3px solid transparent;
    font-weight: 700;
    color: #374151;
    user-select: none;
  }

  .tab.active {
    border-color: #2563eb;
    color: #2563eb;
  }

  .tab-panel {
    display: none;
  }

  .tab-panel.active {
    display: block;
  }

  .group {
    margin-bottom: 16px;
  }

  .group label {
    display: block;
    font-weight: 700;
    margin-bottom: 6px;
    color: #111827;
  }

  .hint {
    font-size: 12px;
    color: #6b7280;
    margin-top: 6px;
    line-height: 1.35;
  }

  input[type=text],
  input[type=password],
  select {
    width: 100%;
    padding: 8px 10px;
    border-radius: 8px;
    border: 1px solid #d1d5db;
    outline: none;
  }

  input[type=range] {
    width: 100%;
  }

  .row {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .pill {
    padding: 6px 10px;
    border-radius: 999px;
    background: #f3f4f6;
    color: #111827;
    font-weight: 700;
    font-size: 12px;
    min-width: 92px;
    text-align: center;
  }

  /* Static JSON Box */
  #staticJson {
    font-family: monospace;
    font-size: 11px;
    background: #f9fafb;
    border: 1px solid #e5e7eb;
    padding: 10px;
    border-radius: 8px;
    color: #4b5563;
    white-space: pre-wrap;
    word-break: break-all;
  }

  /* RIGHT: PREVIEW */
  .preview {
    flex: 1;
    position: relative;
    background: #050505;
  }

  canvas {
    width: 100%;
    height: 100%;
    display: block;
  }

  .overlay {
    position: absolute;
    left: 14px;
    right: 14px;
    bottom: 12px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    pointer-events: none;
    color: rgba(255,255,255,0.75);
    font-size: 12px;
  }

  .overlay .box {
    padding: 6px 10px;
    border-radius: 10px;
    background: rgba(0,0,0,0.5);
    backdrop-filter: blur(4px);
  }

  .small {
    font-size: 12px;
    color: #6b7280;
  }
</style>
</head>

<body>
<div class="card">
  <header>
    <img src="cube.jpg" alt="Cube" />
    <div>
      <h1>LED Cube Control</h1>
      <div class="small">Top-View 3D Render • Background Heat Mapping</div>
    </div>
  </header>

  <div class="content">
    <div class="controls">
      <div class="tabs">
        <div class="tab active" data-tab="server">Server</div>
        <div class="tab" data-tab="heat">Heat</div>
        <div class="tab" data-tab="custom">Custom</div>
      </div>

      <div class="tab-panel active" id="tab-server">
        <div class="group">
          <label>Server</label>
          <input id="server" type="text" value="192.168.1.182:8080" />
        </div>
        <div class="group">
          <label>Token</label>
          <input id="token" type="password" value="1234567890" />
        </div>
      </div>

      <div class="tab-panel" id="tab-heat">
        <div class="group">
          <label>Temperature (BG Color)</label>
          <div class="row">
            <div class="grow w-full">
              <input id="heat-level" type="range" min="0" max="100" value="0" />
            </div>
            <div class="pill" id="heat-level-pill">55</div>
          </div>
        </div>

        <div class="group">
          <label>Ring Width</label>
          <div class="row">
            <div class="grow w-full">
              <input id="heat-width" type="range" min="2" max="100" value="10" />
            </div>
            <div class="pill" id="heat-width-pill">10</div>
          </div>
        </div>

        <div class="group">
          <label>Arc Percent</label>
          <div class="row">
            <div class="grow w-full">
              <input id="heat-percent" type="range" min="0" max="100" value="100" />
            </div>
            <div class="pill" id="heat-percent-pill">100%</div>
          </div>
        </div>
      </div>

      <div class="tab-panel" id="tab-custom">
        <div class="group">
          <label>Geometry</label>
          <select id="geom">
            <option value="ring">Ring</option>
            <option value="circle">Circle (filled)</option>
            <option value="square">Square</option>
            <option value="triangle">Triangle</option>
            <option value="x">X</option>
          </select>
        </div>

        <div class="row mb-4">
          <div class="flex-1">
            <label>Front Color</label>
            <input id="custom-elem-color" type="color" value="#ffffff" />
          </div>
          <div class="flex-1">
            <label>Cube Color</label>
            <input id="custom-bg-color" type="color" value="#0000ff" />
          </div>
        </div>

        <div class="group">
          <label>Width</label>
          <input id="custom-width" type="range" min="2" max="100" value="10" />
        </div>

        <div class="group">
          <label>Percent</label>
          <input id="custom-percent" type="range" min="0" max="100" value="100" />
        </div>
      </div>

      <div class="group pt-4 border-t border-gray-100">
        <label class="text-xs text-gray-400 uppercase tracking-wider">Payload Preview</label>
        <div id="staticJson">JSON: idle</div>
      </div>
    </div>

    <div class="preview">
      <canvas id="gl"></canvas>
      <div class="overlay">
        <div class="box" id="overlayMode">Mode: heat</div>
        <div class="box" id="overlayJson">Status: Ready</div>
      </div>
    </div>
  </div>
</div>

<script>
/* ======================================================
   CONFIG / API
====================================================== */
const API = {
  server: () => document.getElementById("server").value,
  token:  () => document.getElementById("token").value,
  intervalMs: 2000
};

/* ======================================================
   STATE
====================================================== */
const state = {
  mode: "heat",
  geom: "ring",                  // ring | circle | square | triangle | x
  color: { value: 0 },           // ❄️ cold start
  ring: { width: 10, percent: 1.0 },
  background: { hex: "#0000ff" },
  elem: { hex: "#ffffff" }
};

/* ======================================================
   HELPERS
====================================================== */
const el = id => document.getElementById(id);

function hexToRgb01(hex) {
  return [
    parseInt(hex.substr(1,2),16)/255,
    parseInt(hex.substr(3,2),16)/255,
    parseInt(hex.substr(5,2),16)/255
  ];
}

function getHeatBG(v) {
  const t = v / 100;
  if (t < 0.5) {
    const s = t * 2.0;
    return [0.1*(1-s)+1.0*s, 0.2*(1-s)+0.9*s, 0.8*(1-s)+0.2*s];
  } else {
    const s = (t-0.5)*2.0;
    return [1.0, 0.9*(1-s)+0.1*s, 0.2*(1-s)+0.05*s];
  }
}

/* ======================================================
   HEAT GRADIENT BAR
====================================================== */
function ensureHeatGradientBar() {
  const slider = el("heat-level");
  if (!slider) return;
  const parent = slider.parentElement;
  if (parent.querySelector(".heat-gradient")) return;

  const bar = document.createElement("div");
  bar.className = "heat-gradient";
  bar.style.height = "10px";
  bar.style.borderRadius = "999px";
  bar.style.marginBottom = "8px";
  bar.style.border = "1px solid rgba(0,0,0,0.08)";
  bar.style.background =
    "linear-gradient(90deg,#1e3a8a 0%,#3b82f6 25%,#facc15 55%,#f97316 75%,#dc2626 100%)";

  parent.insertBefore(bar, slider);
}

/* ======================================================
   TABS & UI
====================================================== */
document.querySelectorAll(".tab").forEach(tab => {
  tab.onclick = () => {
    document.querySelectorAll(".tab").forEach(t=>t.classList.remove("active"));
    document.querySelectorAll(".tab-panel").forEach(p=>p.classList.remove("active"));
    tab.classList.add("active");
    el("tab-"+tab.dataset.tab).classList.add("active");
    state.mode = tab.dataset.tab;
    el("overlayMode").textContent = "Mode: " + state.mode;
    updateFromUI();
  };
});

function updateFromUI() {
  el("heat-level-pill").textContent = el("heat-level").value;
  el("heat-width-pill").textContent = el("heat-width").value;
  el("heat-percent-pill").textContent = el("heat-percent").value + "%";

  state.color.value = parseInt(el("heat-level").value,10);
  state.geom = el("geom").value;
  state.elem.hex = el("custom-elem-color").value;
  state.background.hex = el("custom-bg-color").value;

  const wEl = state.mode === "heat" ? el("heat-width") : el("custom-width");
  const pEl = state.mode === "heat" ? el("heat-percent") : el("custom-percent");

  state.ring.width = parseInt(wEl.value,10);
  state.ring.percent = parseInt(pEl.value,10)/100.0;
}

/**
 * Event Listener Configuration
 * ----------------------------
 * This block synchronizes the HTML UI elements with both the 
 * local WebGL preview and the remote Raspberry Pi controller.
 */
document.querySelectorAll("input,select").forEach(n => {
  
  /**
   * 'input' event: Fires continuously as the user moves a slider 
   * or types in a field.
   */
  n.addEventListener("input", () => {
    // Update local state and WebGL preview at 60fps
    updateFromUI();

    // Note: We do not call sendToCube(true) here to prevent 
    // flooding the network with requests during every pixel of 
    // slider movement. The background interval (setInterval) 
    // handles the transmission of these intermediate values.
  });
  
  /**
   * 'change' event: Fires when the user interaction is finished 
   * (e.g., releasing the mouse button after dragging a slider).
   */
  n.addEventListener("change", () => {
    // Finalize the local UI state
    updateFromUI();
    
    // Force an immediate network synchronization.
    // By passing 'true', we ensure the final value is sent 
    // regardless of the 10-second heartbeat timer.
    sendToCube(true); 
  });
});

/* ======================================================
   JSON / CUBE PAYLOAD
====================================================== */

function buildCubePayload() {

  // HEAT MODE
  if (state.mode === "heat") {
    return {
      mode: "heat",
      geometry: "ring",
      colour: state.color.value,
      elementColor: "#ffffff",
      width: state.ring.width,
      percent: state.ring.percent
    };
  }

  // CUSTOM MODE
  return {
    mode: "custom",
    geometry: state.geom,
    width: state.ring.width,
    percent: state.ring.percent,
    elementColor: state.elem.hex,
    backgroundColor: state.background.hex
  };
}

function updateJsonOverlay(payload, status = "") {
  const pretty = JSON.stringify(payload, null, 2);
  el("staticJson").textContent =
    pretty + (status ? "\n" + status : "");
}

/* ======================================================
   SEND TO CUBE (REST)
====================================================== */
let lastSentJson = "";
let lastSentTime = 0; // Timestamp of last successful transmission

/**
 * Synchronizes the UI state with the LED hardware.
 * @param {boolean} force - If true, ignores deduplication and heartbeat checks.
 */
async function sendToCube(force = false) {
  const payload = buildCubePayload();
  const json = JSON.stringify(payload);
  const now = Date.now();
  
  updateJsonOverlay(payload);

  // Logic: Only proceed if data changed, OR 10s passed, OR force is true
  const isDataChanged = json !== lastSentJson;
  const isHeartbeatDue = (now - lastSentTime) > 10000;

  if (!isDataChanged && !isHeartbeatDue && !force) {
    return; 
  }
  
  // Update tracking variables before the async call to prevent rapid double-sends
  lastSentJson = json;
  lastSentTime = now;

  let url = API.server().trim();
  if (!url.startsWith("http")) url = "http://" + url;
  url = url.replace(/\/$/, "") + "/update";

  try {
    const res = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-API-Token": API.token()
      },
      body: json
    });

    el("overlayJson").textContent =
      res.ok ? "JSON: sent ✓" : "JSON: error";

  } catch (e) {
    el("overlayJson").textContent = "SERVER: offline";
    // Reset lastSentJson on error so we try again next interval
    lastSentJson = ""; 
  }
}

// Corrected Interval: Check every API.intervalMs if an update is needed
setInterval(() => sendToCube(false), API.intervalMs);

/* ======================================================
   WEBGL
====================================================== */
const canvas = el("gl");
const gl = canvas.getContext("webgl",{antialias:true});

const vs=`
attribute vec2 pos;
varying vec2 v_uv;
void main(){
  v_uv=pos*0.5+0.5;
  gl_Position=vec4(pos,0.0,1.0);
}`;

const fs=`
precision mediump float;
varying vec2 v_uv;
uniform float u_time,u_width,u_pct;
uniform int u_geom;
uniform vec3 u_elemCol,u_bgCol;

float ringShape(vec2 p,float r,float w){
  float d=length(p);
  return smoothstep(r-w,r,d)-smoothstep(r,r+w,d);
}
float squareFrame(vec2 p,float s,float w){
  vec2 d=abs(p);
  float o=max(d.x,d.y);
  return step(s-w,o)-step(s,o);
}
float triangleFrame(vec2 p,float s,float w){
  p*=1.25;p.y+=0.12;
  float k=1.73205;
  vec2 q=vec2(abs(p.x),p.y);
  float o=max(q.x*k+q.y,q.y*2.0);
  return step(s-w,o)-step(s,o);
}
float xShape(vec2 p,float l,float w){
  float a=0.785;
  float ca=cos(a),sa=sin(a);
  vec2 r1=vec2(ca*p.x-sa*p.y,sa*p.x+ca*p.y);
  vec2 r2=vec2(ca*p.x+sa*p.y,-sa*p.x+ca*p.y);
  return clamp(step(abs(r1.y),w)*step(abs(r1.x),l)
             +step(abs(r2.y),w)*step(abs(r2.x),l),0.0,1.0);
}
void cubeMask(vec2 uv,out float m,out float sh){
  float s=0.65,cy=0.10,dx=abs(uv.x);
  bool t=uv.y>cy+dx*0.5&&uv.y<cy+0.65-dx*0.5&&dx<s;
  bool l=uv.x<0.0&&uv.x>-s&&uv.y<cy+(-uv.x)*0.5&&uv.y>cy-0.85+(-uv.x)*0.5;
  bool r=uv.x>=0.0&&uv.x<s&&uv.y<cy+uv.x*0.5&&uv.y>cy-0.85+uv.x*0.5;
  if(t){m=1.0;sh=1.25;}
  else if(l){m=1.0;sh=0.85;}
  else if(r){m=1.0;sh=0.70;}
  else{m=0.0;sh=0.0;}
}

void main() {
  // Normalized UV space
  vec2 uv = v_uv * 2.0 - 1.0;
  uv.y *= 1.15;

  // Cube mask (top / left / right faces)
  float m, sh;
  cubeMask(uv, m, sh);
  if (m < 0.5) {
    gl_FragColor = vec4(0.02, 0.02, 0.03, 1.0);
    return;
  }

  // --------------------------------------------------
  // Rotate geometry space 90° clockwise
  // (x,y) -> (y,-x)
  // --------------------------------------------------
  vec2 p = vec2(-uv.y, uv.x);

  // Organic wobble (visual only)
  float wob =
      sin(u_time * 2.2 + p.x * 4.0) +
      sin(u_time * 1.7 + p.y * 3.0);
  p *= 1.0 + wob * 0.012;

  // --------------------------------------------------
  // Geometry parameters
  // --------------------------------------------------
  float r     = 0.45;
  float dW    = u_width * 0.005 * 0.25; // thick width (preview scale)
  float thinW = 0.006;                  // thin baseline (~2px look)

  // --------------------------------------------------
  // Percent angle (shared by ALL shapes)
  // --------------------------------------------------
  float a = (atan(p.y, p.x) / 6.2831853) + 0.5;
  a = 1.0 - a;              // reverse direction
  float pm = step(a, u_pct);

  // --------------------------------------------------
  // Thin + thick shape variants
  // --------------------------------------------------
  float thinShape  = 0.0;
  float thickShape = 0.0;

  if (u_geom == 0) {
    // Ring
    thinShape  = ringShape(p, r, thinW);
    thickShape = ringShape(p, r, dW);
  }
else if (u_geom == 1) {
  // Filled circle as cake slice (true pie)
  float radial = 1.0 - smoothstep(r - 0.01, r + 0.01, length(p));

  // Outside percent → nothing
  thinShape = 0.0;

  // Inside percent → filled disc
  thickShape = radial;
}
  else if (u_geom == 2) {
    // Square frame
    thinShape  = squareFrame(p, r * 0.85, thinW);
    thickShape = squareFrame(p, r * 0.85, dW);
  }
  else if (u_geom == 3) {
    // Triangle frame
    thinShape  = triangleFrame(p, r * 0.9, thinW);
    thickShape = triangleFrame(p, r * 0.9, dW);
  }
  else if (u_geom == 4) {
    // X shape
    thinShape  = xShape(p, r * 0.9, thinW * 1.3);
    thickShape = xShape(p, r * 0.9, dW   * 1.3);
  }

  // --------------------------------------------------
  // Percent blends THICKNESS, never visibility
  // --------------------------------------------------
  float shape = mix(thinShape, thickShape, pm);

  // --------------------------------------------------
  // Final color composition
  // --------------------------------------------------
  gl_FragColor = vec4(u_bgCol * sh + u_elemCol * shape, 1.0);
}
`;

function compile(t,s){
  const sh=gl.createShader(t);
  gl.shaderSource(sh,s);
  gl.compileShader(sh);
  return sh;
}

const prog=gl.createProgram();
gl.attachShader(prog,compile(gl.VERTEX_SHADER,vs));
gl.attachShader(prog,compile(gl.FRAGMENT_SHADER,fs));
gl.linkProgram(prog);
gl.useProgram(prog);

const buf=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,buf);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),gl.STATIC_DRAW);
const pLoc=gl.getAttribLocation(prog,"pos");
gl.enableVertexAttribArray(pLoc);
gl.vertexAttribPointer(pLoc,2,gl.FLOAT,false,0,0);

const U={
  t:gl.getUniformLocation(prog,"u_time"),
  w:gl.getUniformLocation(prog,"u_width"),
  p:gl.getUniformLocation(prog,"u_pct"),
  g:gl.getUniformLocation(prog,"u_geom"),
  e:gl.getUniformLocation(prog,"u_elemCol"),
  b:gl.getUniformLocation(prog,"u_bgCol")
};

function render(ms){
  canvas.width=canvas.clientWidth;
  canvas.height=canvas.clientHeight;
  gl.viewport(0,0,canvas.width,canvas.height);

  const isHeat=state.mode==="heat";
  const eCol=isHeat?[1,1,1]:hexToRgb01(state.elem.hex);
  const bCol=isHeat?getHeatBG(state.color.value):hexToRgb01(state.background.hex);
  const gMap={ring:0,circle:1,square:2,triangle:3,x:4};

  gl.uniform1f(U.t,ms/1000);
  gl.uniform1f(U.w,state.ring.width);
  gl.uniform1f(U.p,state.ring.percent);
  gl.uniform1i(U.g,gMap[state.geom]);
  gl.uniform3fv(U.e,eCol);
  gl.uniform3fv(U.b,bCol);

  gl.drawArrays(gl.TRIANGLES,0,6);
  requestAnimationFrame(render);
}

/* ======================================================
   INIT
====================================================== */
ensureHeatGradientBar();
updateFromUI();
requestAnimationFrame(render);
</script>

</body>
</html>
